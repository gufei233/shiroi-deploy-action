name: Build and Deploy Shiroi (Standalone)

on:
  push:
    branches:
      - main
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  repository_dispatch:
    types: [trigger-workflow]  # å…è®¸å¤–éƒ¨ä»“åº“é€šè¿‡ API è§¦å‘

permissions: write-all

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  HASH_FILE: build_hash

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    if: ${{ github.event.head_commit.message != 'Update hash file' }}

    outputs:
      hash_content: ${{ steps.read_hash.outputs.hash_content }}

    steps:
      - name: Checkout deploy repo
        uses: actions/checkout@v4

      - name: Read HASH_FILE content
        id: read_hash
        run: |
          content=$(cat ${{ env.HASH_FILE }}) || true
          echo "hash_content=$content" >> "$GITHUB_OUTPUT"

  check:
    name: Check Should Rebuild
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      canceled: ${{ steps.use_content.outputs.canceled }}
      current_hash: ${{ steps.use_content.outputs.current_hash }}

    steps:
      - name: Checkout Shiroi repo
        uses: actions/checkout@v4
        with:
          repository: innei-dev/shiroi
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0
          lfs: true

      - name: Compare hash
        id: use_content
        env:
          FILE_HASH: ${{ needs.prepare.outputs.hash_content }}
        run: |
          file_hash=$FILE_HASH
          current_hash=$(git rev-parse --short HEAD)
          echo "File Hash: $file_hash"
          echo "Current Git Hash: $current_hash"
          echo "current_hash=$current_hash" >> $GITHUB_OUTPUT

          if [ "$file_hash" == "$current_hash" ]; then
            echo "Hashes match. Stopping workflow."
            echo "canceled=true" >> $GITHUB_OUTPUT
          else
            echo "Hashes do not match. Continuing workflow."
          fi

  build:
    name: Build Shiroi
    runs-on: ubuntu-latest
    needs: check
    if: ${{ needs.check.outputs.canceled != 'true' }}

    strategy:
      matrix:
        node-version: [20.x]

    outputs:
      sha_short: ${{ steps.store.outputs.sha_short }}

    steps:
      - name: Checkout Shiroi repo
        uses: actions/checkout@v4
        with:
          repository: innei-dev/shiroi
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0
          lfs: true

      - name: Checkout LFS objects
        run: git lfs checkout

      - uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Remove outdated lockfile
        run: rm -f pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install

      - name: Download .env from server
        run: |
          # ä½¿ç”¨ sshpass + scp ä»ŽæœåŠ¡å™¨ä¸‹è½½ .env
          mkdir -p server-env

          # æ ¹æ®è®¤è¯æ–¹å¼é€‰æ‹©ä¸åŒçš„ scp å‘½ä»¤
          if [ -n "${{ secrets.KEY }}" ]; then
            # ä½¿ç”¨ SSH Key
            echo "${{ secrets.KEY }}" > /tmp/ssh_key
            chmod 600 /tmp/ssh_key
            scp -P ${{ secrets.PORT }} -i /tmp/ssh_key -o StrictHostKeyChecking=no \
              ${{ secrets.USER }}@${{ secrets.HOST }}:Shiroi/.env \
              server-env/.env
            rm /tmp/ssh_key
          else
            # ä½¿ç”¨å¯†ç ï¼ˆéœ€è¦ sshpassï¼‰
            sudo apt-get update && sudo apt-get install -y sshpass
            sshpass -p "${{ secrets.PASSWORD }}" scp -P ${{ secrets.PORT }} -o StrictHostKeyChecking=no \
              ${{ secrets.USER }}@${{ secrets.HOST }}:Shiroi/.env \
              server-env/.env
          fi

          echo "âœ“ å·²ä»ŽæœåŠ¡å™¨ä¸‹è½½ .env æ–‡ä»¶"

      - name: Copy .env to build location
        run: |
          # å°†ä¸‹è½½çš„ .env å¤åˆ¶åˆ° apps/web/
          cp server-env/.env apps/web/.env
          echo "âœ“ å·²å¤åˆ¶ .env æ–‡ä»¶åˆ°æž„å»ºç›®å½•"

          # ç»Ÿè®¡çŽ¯å¢ƒå˜é‡æ•°é‡ï¼ˆä¸è¾“å‡ºå†…å®¹ï¼‰
          env_count=$(grep -c "NEXT_PUBLIC_" apps/web/.env || echo "0")
          echo "âœ“ æ£€æµ‹åˆ° $env_count ä¸ª NEXT_PUBLIC_* çŽ¯å¢ƒå˜é‡"

      - name: Build project
        run: pnpm --filter @shiro/web build

      - name: Prepare deployment bundle
        run: |
          cd apps/web

          # åˆ›å»ºéƒ¨ç½²ç›®å½•
          mkdir -p deploy-bundle

          # å¤åˆ¶ standalone ç›®å½•ä½œä¸ºåŸºç¡€ï¼ˆåŒ…å« apps/ ç»“æž„å’Œä¿®æ”¹è¿‡çš„ package.jsonï¼‰
          echo "=== Copying standalone structure ==="
          cp -r .next/standalone/* deploy-bundle/

          # åˆ é™¤ standalone ä¸­çš„ node_modulesï¼ˆç¨åŽåœ¨æœåŠ¡å™¨ä¸Šå®‰è£…ï¼‰
          rm -rf deploy-bundle/node_modules
          rm -rf deploy-bundle/apps/web/node_modules

          # ä¿®æ”¹ apps/web/package.jsonï¼Œç§»é™¤ workspace ä¾èµ–
          echo "=== Fixing workspace dependencies ==="
          if [ -f "deploy-bundle/apps/web/package.json" ]; then
            # ä½¿ç”¨ Node.js ä¿®æ”¹ package.json
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('deploy-bundle/apps/web/package.json', 'utf8'));

              // ç§»é™¤ workspace ä¾èµ–
              if (pkg.dependencies) {
                Object.keys(pkg.dependencies).forEach(key => {
                  if (pkg.dependencies[key].startsWith('workspace:')) {
                    delete pkg.dependencies[key];
                  }
                });
              }

              if (pkg.devDependencies) {
                Object.keys(pkg.devDependencies).forEach(key => {
                  if (pkg.devDependencies[key].startsWith('workspace:')) {
                    delete pkg.devDependencies[key];
                  }
                });
              }

              fs.writeFileSync('deploy-bundle/apps/web/package.json', JSON.stringify(pkg, null, 2));
            "
            echo "âœ“ Removed workspace dependencies"
          fi

          # å¤åˆ¶ static å’Œ public åˆ°æ­£ç¡®ä½ç½®
          echo "=== Copying static assets ==="
          mkdir -p deploy-bundle/apps/web/.next/static
          cp -r .next/static/* deploy-bundle/apps/web/.next/static/

          mkdir -p deploy-bundle/apps/web/public
          cp -r public/* deploy-bundle/apps/web/public/

          # æ·»åŠ è¿›ç¨‹æ ‡é¢˜
          echo ';process.title = "Shiro (NextJS)"' >> deploy-bundle/apps/web/server.js

          # æ‰“åŒ…
          echo "=== Creating deployment archive ==="
          mkdir -p assets
          cd deploy-bundle
          zip -r ../assets/release.zip ./* -x "*/cache/*" "*/.git/*"

          echo "=== Bundle created ==="
          ls -lh ../assets/release.zip

      - name: Cache build artifacts
        uses: actions/cache/save@v4
        with:
          path: apps/web/assets
          key: ${{ github.run_number }}-release

      - name: Store commit hash
        id: store
        run: |
          sha_short=$(git rev-parse --short HEAD)
          echo "sha_short=$sha_short" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: apps/web/assets
          key: ${{ github.run_number }}-release

      - name: Move release file
        run: mv apps/web/assets/release.zip release.zip

      - name: Upload to server via SCP
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          password: ${{ secrets.PASSWORD }}
          key: ${{ secrets.KEY }}
          port: ${{ secrets.PORT }}
          source: 'release.zip'
          target: '/tmp/shiroi'

      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          command_timeout: 10m
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          password: ${{ secrets.PASSWORD }}
          key: ${{ secrets.KEY }}
          port: ${{ secrets.PORT }}
          script: |
            set -e
            source $HOME/.bashrc

            # é…ç½®è·¯å¾„
            BASEDIR=$HOME/Shiroi
            WORKDIR=$BASEDIR/releases/${{ github.run_number }}
            ENV_FILE=$BASEDIR/.env

            echo "ðŸ“¦ å¼€å§‹éƒ¨ç½² Shiroi..."

            # åˆ›å»ºå·¥ä½œç›®å½•
            mkdir -p $WORKDIR
            mkdir -p $BASEDIR/.cache

            # ç§»åŠ¨å¹¶è§£åŽ‹
            mv /tmp/shiroi/release.zip $WORKDIR/release.zip
            rm -rf /tmp/shiroi
            cd $WORKDIR
            echo "ðŸ“‚ è§£åŽ‹æž„å»ºäº§ç‰©..."
            unzip -qq -o release.zip
            rm release.zip

            # å®šä½ monorepo æ ¹ç›®å½•
            MONOREPO_ROOT=$WORKDIR

            if [ ! -d "$MONOREPO_ROOT/apps/web" ]; then
              echo "âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ° apps/web ç›®å½•"
              echo "ç›®å½•ç»“æž„ï¼š"
              ls -la $WORKDIR
              exit 1
            fi

            echo "âœ“ æ‰¾åˆ° monorepo æ ¹ç›®å½•"

            # apps/web çš„å®žé™…è·¯å¾„
            STANDALONE_DIR="$MONOREPO_ROOT/apps/web"

            # åœ¨ apps/web ç›®å½•å®‰è£…ä¾èµ–
            echo "ðŸ“¦ å®‰è£…ç”Ÿäº§ä¾èµ–ï¼ˆè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿï¼‰..."
            cd $STANDALONE_DIR

            # æ£€æŸ¥æ˜¯å¦æœ‰ package.json
            if [ ! -f "package.json" ]; then
              echo "âŒ é”™è¯¯ï¼šapps/web/package.json ä¸å­˜åœ¨"
              ls -la $STANDALONE_DIR
              exit 1
            fi

            # å®‰è£…ä¾èµ–
            if [ -f "pnpm-lock.yaml" ]; then
              pnpm install --prod --frozen-lockfile
            else
              echo "âš ï¸  æ²¡æœ‰ lockfileï¼Œå°†ç”Ÿæˆæ–°çš„"
              pnpm install --prod
            fi

            # å¤åˆ¶ .env æ–‡ä»¶åˆ° monorepo æ ¹ç›®å½•
            if [ ! -f "$ENV_FILE" ]; then
              echo "âŒ é”™è¯¯ï¼š$ENV_FILE ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º .env æ–‡ä»¶"
              exit 1
            fi

            echo "ðŸ“ å¤åˆ¶çŽ¯å¢ƒå˜é‡..."
            cp $ENV_FILE $MONOREPO_ROOT/.env

            # åˆ›å»ºæ—¥å¿—ç›®å½•
            mkdir -p $BASEDIR/logs

            # æ¯æ¬¡éƒ¨ç½²éƒ½æ›´æ–° PM2 é…ç½®ï¼Œå°† cwd ç¡¬ç¼–ç ä¸ºå½“å‰ç‰ˆæœ¬è·¯å¾„
            # pm2 restart/reload ä¸ä¼šæ›´æ–°å·²è¿è¡Œè¿›ç¨‹çš„ cwdï¼Œå¿…é¡»é€šè¿‡æ›´æ–°é…ç½®æ–‡ä»¶è§£å†³
            echo "ðŸ“ æ›´æ–° PM2 é…ç½®..."
            cat > $BASEDIR/ecosystem.config.cjs << EOFPM2
            module.exports = {
              apps: [{
                name: 'Shiro',
                script: './apps/web/server.js',
                cwd: '$MONOREPO_ROOT',
                instances: 1,
                exec_mode: 'cluster',
                env: {
                  NODE_ENV: 'production',
                  PORT: 2323,
                  HOSTNAME: '0.0.0.0',
                },
                error_file: '$BASEDIR/logs/err.log',
                out_file: '$BASEDIR/logs/out.log',
                log_date_format: 'YYYY-MM-DD HH:mm:ss',
                merge_logs: true,
                max_memory_restart: '1G',
                autorestart: true,
                watch: false,
              }],
            }
            EOFPM2

            # é“¾æŽ¥ç¼“å­˜ç›®å½•ï¼ˆå¯é€‰ï¼ŒåŠ é€ŸåŽç»­æž„å»ºï¼‰
            if [ -d "$STANDALONE_DIR/.next" ]; then
              rm -rf $STANDALONE_DIR/.next/cache
              ln -sf $BASEDIR/.cache $STANDALONE_DIR/.next/cache
            fi

            # æ›´æ–° current ç¬¦å·é“¾æŽ¥ï¼ˆæŒ‡å‘ monorepo æ ¹ç›®å½•ï¼‰
            echo "ðŸ”— æ›´æ–°å½“å‰ç‰ˆæœ¬é“¾æŽ¥..."
            rm -f $BASEDIR/current
            ln -sf $MONOREPO_ROOT $BASEDIR/current

            # é‡è½½ PM2ï¼ˆcluster æ¨¡å¼ä¸‹é›¶åœæœºï¼‰
            echo "ðŸ”„ é‡è½½æœåŠ¡..."
            cd $BASEDIR

            # æ£€æŸ¥ PM2 è¿›ç¨‹æ˜¯å¦å­˜åœ¨
            if pm2 describe Shiro > /dev/null 2>&1; then
              pm2 reload ecosystem.config.cjs --update-env
            else
              pm2 start ecosystem.config.cjs
            fi

            pm2 save

            echo "âœ… éƒ¨ç½²æˆåŠŸï¼"
            echo "ðŸ“Š æœåŠ¡çŠ¶æ€ï¼š"
            pm2 status Shiro

            # æ¸…ç†æ—§ç‰ˆæœ¬ï¼ˆä¿ç•™æœ€è¿‘ 3 ä¸ªï¼‰
            echo "ðŸ§¹ æ¸…ç†æ—§ç‰ˆæœ¬..."
            cd $BASEDIR/releases
            ls -t | tail -n +4 | xargs -r rm -rf

            echo "ðŸŽ‰ éƒ¨ç½²å®Œæˆï¼ç‰ˆæœ¬: ${{ github.run_number }}"

      - name: After deploy hook
        if: success()
        run: |
          echo "Deployment successful"
          ${{ secrets.AFTER_DEPLOY_SCRIPT }}

  store:
    name: Store commit hash
    runs-on: ubuntu-latest
    needs: [deploy, build]

    steps:
      - name: Checkout deploy repo
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Write hash to file
        env:
          SHA_SHORT: ${{ needs.build.outputs.sha_short }}
        run: echo $SHA_SHORT > ${{ env.HASH_FILE }}

      - name: Commit hash file
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add ${{ env.HASH_FILE }}
          git commit -m "Update hash file to ${{ needs.build.outputs.sha_short }}"

      - name: Push changes
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}
